# -*- coding: utf-8 -*-
"""fem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mn7p6j1JMX2mZEO1lHDmBIWU4tdrDlid
"""

from IPython.display import clear_output
from scipy.sparse import csr_matrix
import matplotlib.pyplot as plt
import numpy as np
import os

#### PRELIMINARIES ####

def install():
    """If missing, installs fenics and gmsh on Google Colab."""
    ready = True
    try:
        import dolfin
    except ImportError:
        ready = False
        print("Installing fenics... this should take about 30-60 seconds.")
        os.system('wget "https://fem-on-colab.github.io/releases/fenics-install-real.sh" -O "/tmp/fenics-install.sh" && bash "/tmp/fenics-install.sh"')

    try:
        import gmsh
    except ImportError:
        ready = False
        print("Installing gmsh... this should take about 30-60 seconds.")
        os.system('wget "https://fem-on-colab.github.io/releases/gmsh-install.sh" -O "/tmp/gmsh-install.sh" && bash "/tmp/gmsh-install.sh"')
    clear_output()

install()


from fenics import dx, ds, grad, inner
deriv = lambda v: v.dx(0)

#### FINITE ELEMENT SPACES ####

def FEspace(mesh, r):
    """Constructs a Python object representing a Finite Element space (continuous Lagrange elements of
    a given polynomial degree). The latter can be later used to define functions, linear and bilinear forms,
    plots, etc.

    Input:
       mesh    (dolfin.cpp.mesh.Mesh)   Object representing the underlying mesh (cf. fem.generate_mesh).
       r       (int)                    Polynomial degree.

    Output:
       Finite Element space, returned as a fenics.FunctionSpace.
    """
    from fenics import FunctionSpace
    V = FunctionSpace(mesh, 'CG', r)
    clear_output()
    return V

def dof2fun(u, V):
    """
    Converts a vector of nodal values onto its corresponding function representation in the Finite
    Element space.

    Input:
       u   (numpy.ndarray)             Vector of nodal values (dof-vector).
       V   (fenics.FunctionSpace)      Finite Element space (cf. fem.FEspace) where u should be mapped.

    Output:
       Function representation of u, as an element of V. Returned as a fenics.Function object.
    """
    from fenics import Function
    uf = Function(V)
    uf.vector()[:] = u + 0.0
    return uf

def fun2dof(uf):
    """
    Vector of nodal values of a given function being part of a Finite Element space.

    Input:
       uf   (fenics.Function)    Function part of a Finite Element space.

    Output:
       dof representation of uf, returned as a numpy.ndarray vector.
    """
    return uf.vector()[:]

def interpolate(expression, V):
    """
    Interpolates a given continuous function onto a given Finite Element space.

    Input:
       expression   (function or float)          Function to be interpolated, defined analytically
                                                 as a Python function (either using "def" or lambda functions).
                                                 If a float value is detected, the function is assumed to be
                                                 constant.

                                                 Ex: letting expression = 1.0 or expression = lambda x: 1.0 is
                                                 exactly equivalent.

       V            (fenics.FunctionSpace)       Finite Element space (cf. fem.FEspace) where the
                                                 interpolation is supposed to happen.

    Output:
       Function representative of "expression" within the space V. Returned as a fenics.Function object.
    """
    c = dofs(V).T
    if(callable(expression)):
      values = expression(*c)
    else:
      values = expression
    if(isinstance(values, list)):
        values = np.stack([v + 0*q for v, q in zip(values, c)], axis = 1).reshape(-1)

        from fenics import VectorElement, FunctionSpace
        element = VectorElement(V.ufl_element().family(), V.mesh().ufl_cell(), V.ufl_element().degree())
        Vvect = FunctionSpace(V.mesh(), element)
        clear_output()
        return dof2fun(values, Vvect)
    else:
        return dof2fun(values, V)

def dofs(V):
    """
    Coordinates of the degrees of freedom (Lagrangian nodes) of a given Finite Element space V.

    Input:
       V  (fenics.FunctionSpace)   Finite Element space of interest (cf. fem.FEspace).

    Output:
       coordinates of the dofs, returned as a Nh x d numpy.ndarray, where d is the spatial dimension.
    """
    return V.tabulate_dof_coordinates()

def plot(obj, axis = None, colorbar = True, shrink = 0.7, levels = None, spaceticks = False, title = None, **kwargs):
    """
    Auxiliary function for plotting meshes, Finite Element spaces, and fenics.Function objects.

    Input:
       obj        (dolfin.cpp.mesh.Mesh or         Object to be visualized.
                   fenics.FunctionSpace or
                   fenics.Function)

       axis       (list or string)                 List with coordinates limits or a string to active/shut off axis
                                                   (use axis = "on" and axis = "off", respectively).

       colorbar   (bool)                           Whether to show or not the colorbar (2D plots only).

       shrink     (float)                          Shrinking factor (between 0 and 1) for the colorbar.

       levels     (None)                           Number of isolines to be interpolated for visualization (2D plots only).
                                                   Defaults to 200.

       spaceticks (bool)                           Whether to force spacing between ticks in the colorbar.

       title      (string)                         Optional title for the plot.

       kwargs     (dict)                           Dictionary containing other additional specifications. For 1D plots,
                                                   all options accepted by matplotlib.pyplot.plot can be passed. For 2D
                                                   plots, all options accepted by fenics.plot can be passed.
    """
    import dolfin
    try:
        axis_ = "off" if axis is None else axis
        if(isinstance(obj, dolfin.cpp.mesh.Mesh)):
            dolfin.common.plotting.plot(obj)
        elif(isinstance(obj, dolfin.function.functionspace.FunctionSpace)):
            dolfin.common.plotting.plot(obj.mesh())
            c = dofs(obj).T
            if(len(c)==1):
              plt.plot(c[0], 0*c[0], '.r', label = 'dofs')
            else:
              plt.plot(*c, '.r', label = 'dofs')
        else:
            if(levels is None):
                levels = np.unique(fun2dof(obj)).shape[0]
            if(obj.function_space().mesh().geometry().dim() != 1):
                c = dolfin.common.plotting.plot(obj, cmap = 'jet', **kwargs)
                if(colorbar):
                    cbar = plt.colorbar(c, shrink = shrink)
                    if(spaceticks):
                        cbar.set_ticks([round(tick, 2) for tick in np.linspace(cbar.vmin, cbar.vmax, 6)])
            else:
              xdofs = dofs(obj.function_space()).reshape(-1)
              a, b = xdofs.min(), xdofs.max()
              xplot = np.linspace(a, b, 1000)
              line1, = plt.plot(xplot, [obj(x) for x in xplot], **{key: kwargs[key] for key in kwargs if key != "marker"})
              if("marker" in kwargs.keys()):
                 plt.plot(xdofs, fun2dof(obj), '.', color = line1.get_color(), linestyle=line1.get_linestyle())
              axis_ = "on"
        plt.axis(axis_)
        if(not (title is None)):
          plt.title(title)
    except Exception as e:
        raise RuntimeError("First argument should be either a dolfin.cpp.mesh.Mesh or a structure containing the dof values of some function (in which case 'space' must be != None).\n\nThis error was caused by the following exception: %s." % str(e))

class DirichletBC(object):
    """
    Python class for defining Dirichlet boundary conditions.
    """

    def __init__(self, where, value):
        """Creates a Dirichlet boundary condition at a specified portion of the domain boundary, with
        a specified value.

        Input:
           where    (function)        Boolean valued function that, given the coordinates of a point x
                                      ON the boundary, returns True or False depending whether the point
                                      lies on the interested region of the boundary.

                                      Ex: for 1D problems on (a, b) pass
                                      where = lambda x: x < a + 1e-12,
                                      or even
                                      where = lambda x: x < (a+b)/2.0
                                      to indicate a Dirichlet condition on x = a.
                                      For multi-dimensional problems, the function should accept coordinates
                                      as additional inputs, e.g. where = lambda x,y in 2D.

           value    (function or float)  Function defined on the domain boundary, corresponding to the
                                         Dirichlet boundary condition. If a float is detected, a space-constant
                                         condition is imposed (same value on all points in the desired portion
                                         of the boundary); see also fem.interpolate.

                                         For 1D problems, float values are suggested.

        Output:
           Dirichlet boundary condition, encoded as a fem.DirichletBC object. Objects of this class
           have two attributes: where and value, corresponding to the two arguments in the
           constructor DirichletBC.__init__.
        """
        self.where = where
        self.value = value

    def apply(self, F, V):
        """
        Apply a Dirichlet boundary condition to either a vector (RHS) or a matrix (LHS).
        Given a linear system Au = F subject to a boundary condition, this method should be applied
        to both A and F (with two separate calls).

        Input:
           F    (numpy.ndarray or scipy.sparse.csr_matrix)     Vector/matrix to which the Dirichlet
                                                               condition should be applied. If F
                                                               is a vector, it is assumed to be the RHS
                                                               of the equation. If F is a matrix, it
                                                               is assumed to be matrix of the linear system
                                                               under study.

           V    (fenics.FunctionSpace)                         Function space where F was assembled.

        Output:
           Modified version of F, hard-coded with the Dirichlet boundary condition.
        """
        from fenics import DirichletBC as dBC
        where = lambda x, on: on and self.where(*x)
        bds = dBC(V, interpolate(self.value, V), where).get_boundary_values()
        if(len(F.shape) == 2):
            F = F.tolil()
            for j in bds.keys():
              F[j, :] = 0
              F[j, j] = 1
            return F.tocsr()

        else:
            for key in bds.keys():
              F[key] = bds[key]
            return F

def applyBCs(F, V, *dbcs):
    """
    Apply a list of Dirichlet boundary conditions to either a vector (RHS) or a matrix (LHS).
    Given a linear system Au = F subject to a boundary condition, this method should be applied
    to both A and F (with two separate calls).

    Input:
        F    (numpy.ndarray or scipy.sparse.csr_matrix)     Vector/matrix to which the Dirichlet
                                                            conditions should be applied. If F
                                                            is a vector, it is assumed to be the RHS
                                                            of the equation. If F is a matrix, it
                                                            is assumed to be matrix of the linear system
                                                            under study.

        V    (fenics.FunctionSpace)                         Function space where F was assembled.

        dbcs (list or tuple of fem.DirichletBC)             Sequence of Dirichlet conditions to be
                                                            applied.

    Note: this function is implemented using the * operator on positional arguments. Consequently,
    acceptable calls can be

    applyBCs(F, V, dbc1)
    applyBCs(F, V, dbc1, dbc2)

    but NOT
    applyBCs(F, V, [dbc1, dbc2])

    In fact, the "list" dbcs is assumed to be unpacked (all elements in dbcs are passed sequentially as
    additional arguments). Pythonically, writing applyBCs(F, V, dbc1, dbc2) is equivalent to
    applyBCs(F, V, *[dbc1, dbc2]).

    Output:
        Modified version of F, hard-coded with all Dirichlet boundary conditions.
    """
    for dbc in dbcs:
        F = dbc.apply(F, V)
    return F

def assemble(F, V):
    """
    Assemble a variational form over a given Finite Element space.

    Input:
       F   (function)   Python function accepting either one input v (linear functional)
                        or two inputs u, v (bilinear form). It should define a suitable variational
                        form in a symbolic way, using u as a trial function and v as a test function,
                        typically relying on dx and ds to indicate domain or boundary integration (cf. fem.dx, fem.ds).

       V   (fenics.FunctionSpace)  Function space where to assemble the variational form (otherwise defined
                                   in an infinite-dimensional space).

    Output:
       Discrete representation of F, returned either as a numpy vector (if F is a linear functional) or
       as a sparse matrix in csr format (if F is a bilinear form). In the latter case, .todense() can be used to
       obtain a dense representation in numpy format.
    """
    from fenics import TrialFunction, TestFunction, assemble as assmb
    u, v = TrialFunction(V), TestFunction(V)

    try:
        L = F(u, v)
        A = assmb(L)
        clear_output()
        return csr_matrix(A.array())
    except:
        f = F(v)
        rhs = assmb(f)
        clear_output()
        return rhs[:]


#### GEOMETRIES, DOMAINS and MESHES ####

class Domain(object):
    """Abstract class for spatial domains in R^d."""
    def __init__(self, main, other, operation = None):
        """Combines two domains via the specified operation."""
        self.a, self.b, self.op = main, other, operation
        self.index = 0
        self.dim = max(main.dim, other.dim)

    def script(self, index = 1):
        """Writes a gmsh script describing the domain."""
        res, j = self.a.script(index)
        res0, j0 = self.b.script(j)
        self.index = j0
        if(self.op == "u"):
            res0 += "BooleanUnion{%s{%d};}{%s{%d};}\n" % (self.a.entity(), self.a.index, self.b.entity(), self.b.index)
        elif(self.op == "i"):
            res0 += "BooleanIntersection{%s{%d};}{%s{%d};}\n" % (self.a.entity(), self.a.index, self.b.entity(), self.b.index)
        elif(self.op == "d"):
            res0 += "BooleanDifference{%s{%d};}{%s{%d};}\n" % (self.a.entity(), self.a.index, self.b.entity(), self.b.index)
        return res+res0, j0+1

    def __add__(self, other):
        return Domain(self, other, "u")

    def __sub__(self, other):
        return Domain(self, other, "d")

    def __mul__(self, other):
        return Domain(self, other, "i")

    def entity(self):
        if self.dim==2:
            return "Surface"
        elif self.dim==3:
            return "Volume"

class Rectangle(Domain):
    def __init__(self, p0, p1):
        self.p0 = p0
        self.p1 = p1
        self.index = 0
        self.dim = 2

    def script(self, index = 1):
        self.index = index
        return 'Rectangle(%d) = {%f, %f, 0.0, %f, %f};\n' % (index,self.p0[0],self.p0[1],self.p1[0]-self.p0[0],
                                                             self.p1[1]-self.p0[1]), index+1

class Box(Domain):
    def __init__(self, p0, p1):
        self.p0 = p0
        self.p1 = p1
        self.index = 0
        self.dim = 3

    def script(self, index = 1):
        self.index = index
        return 'Box(%d) = {%f, %f, %f, %f, %f, %f};\n' % (index,self.p0[0],self.p0[1],self.p0[2],
                                                          self.p1[0]-self.p0[0],self.p1[1]-self.p0[1],self.p1[2]-self.p0[2]), index+1

class Circle(Domain):
    def __init__(self, p, r = 1):
        self.p = p
        self.r = r
        self.index = 0
        self.dim = 2

    def script(self, index = 1):
        self.index = index
        return 'Disk(%d) = {%f, %f, 0.0, %f};\n' % (index,self.p[0], self.p[1], self.r), index+1

class Polygon(Domain):
    def __init__(self, *points):
        self.p = points
        if(np.linalg.norm(np.array(points[0])- np.array(points[-1]))>1e-15):
            raise RuntimeError("First and last point should coincide.")
        self.index = 0
        self.dim = 2

    def script(self, index = 1):
        res = ""
        self.index = index
        n = len(self.p)-1
        for p in self.p[:-1]:
            res += "Point(%d) = {%f, %f, 0.0};\n" % (self.index,p[0],p[1])
            self.index += 1
        base = self.index
        for i in range(n-1):
            res += "Line(%d) = {%d, %d};\n" % (self.index,base-n+i,base-n+1+i)
            self.index += 1
        res += "Line(%d) = {%d, %d};\n" % (self.index,base-1,base-n)
        self.index += 1
        res += "Line Loop(%d) = {" % self.index
        for i in range(n):
            res += "%d, " % (self.index-n+i)
        res = res[:-2] + "};\n"
        self.index += 1
        res += "Plane Surface(%d) = {%d};\n" % (self.index, self.index-1)
        return res, self.index+1

class Line(object):
    """1D domain represented by a straight line from a to b."""
    def __init__(self, a, b):
        """Constructs a straight line from a to b. Used to represent the open interval (a, b).

        Input:
           a   (float)    left extreme of the interval.
           b   (float)    right extreme of the interval.

        Output:
           Spatial domain representing a straight line, returned as a fem.Line object.
        """
        self.a = a
        self.b = b

def generate_mesh(domain, stepsize, structured = False):
    """Discretizes a given spatial domain by introducing a suitable mesh.

    Input:
       domain     (fem.Domain)  Spatial domain to be discretized.

       stepsize   (float)       Stepsize h of the mesh.

       structured (bool)        Whether to use a structured mesh or not (ignored if the domain is 1D).

    Output:
       Computational mesh, returned as dolfin.cpp.mesh.Mesh object.
    """

    if(isinstance(domain, Line)):
        from fenics import IntervalMesh
        return IntervalMesh(int((domain.b-domain.a)/stepsize), domain.a, domain.b)
    else:
        import dolfin
        if(structured and domain.dim!=2):
            raise RuntimeError("Structured meshes are only available for 2D geometries.")
        code = 'SetFactory("OpenCASCADE");\nMesh.CharacteristicLengthMin = %f;\nMesh.CharacteristicLengthMax = %f;\n' % (stepsize, stepsize)
        code += domain.script()[0]
        extra = "\nTransfinite %s {%d};" %  (domain.entity(), domain.index) if structured else ""
        code += '\nPhysical %s(%d) = {%d};%s\nMesh.MshFileVersion = 2.0;' % (domain.entity(), domain.index+1, domain.index, extra)

        idf = np.random.randint(100000)
        print(code, file = open('%d.geo' % idf, 'w'))
        os.system("gmsh -%d %d.geo" % (domain.dim, idf))
        clear_output(wait = True)
        os.system("dolfin-convert %d.msh %d.xml" % (idf, idf))
        clear_output(wait = True)
        mesh = dolfin.cpp.mesh.Mesh("%d.xml" % idf)
        os.remove("%d.msh" % idf)
        os.remove("%d.xml" % idf)
        try:
            os.remove("%d_physical_region.xml" % idf)
        except:
            None
        os.remove("%d.geo" % idf)
        return mesh


#### ERROR COMPUTATION, L2 NORMS, POST-PROCESSING ####

def L2norm(e, mass_matrix):
    """L2 norm of a given function.

    Input:
       e            (numpy.ndarray)              Dof-vector of the underlying function.
       mass_matrix  (scipy.sparse.csr_matrix)    Mass matrix associated to the underlying Finite Element
                                                 space.

                                                 Ex: mass_matrix = assemble(lambda u, v: u*v*dx, V).

    Output:
       L2 norm (float).
    """
    return np.sqrt(e @ (mass_matrix @ e))

def L2error(uex, ufem, domain, hquad = 0.05, rquad = 4):
    """
    L2 norm of the error between a reference solution and a given Finite Element approximation.
    Since the L2 norm involves the computation of an integral, the latter is approximated through
    a suitable quadrature rule.

    Input:
       uex    (function)          Function defining the reference solution analytically.
       ufem   (fenics.Function)   Finite Element approximation.
       domain (fem.Domain)        Spatial domain where the integration is to be carried out.
       hquad  (float)             Stepsize for the quadrature rule (optional, defaults to 0.05).
                                  If needed, it can be reduced to improve accuracy of the error computation.
       rquad  (int)               Polynomial degree for the quadrature rule (optional, defaults to 4).

    Output:
      L2 norm of the error (float).
    """
    from fenics import interpolate as interp
    Vnew = FEspace(generate_mesh(domain, stepsize = hquad),  rquad)
    M = assemble(lambda u, v: u*v*dx, Vnew)
    clear_output()
    c = dofs(Vnew).T
    err = uex(*c) - interp(ufem, Vnew).vector()
    return L2norm(err, M)


### rappresentazione grafica per problemi dipendenti dal tempo



from matplotlib import animation
from matplotlib.colors import Colormap
import imageio

def xtplot(V,u,t, type='animation', color='b',linestyle='-'):
  """ Plotto la soluzione attraverso un'animazione
    V     spazio elementi finiti
    u     (numpy.ndarray)-> matrix  Matrice contenente la soluzione
                                    approssimata del problema. Uij
                                    approssima u(dof_i, tj): ogni colonna è un
                                    tempo fissato.
    t      (numpy.ndarray)-> vector Griglia temporale.
    type      (string)                  'animation' o 'surface o fade'
    color
    linestyle
    marker
  """
  match type:
    case 'animation':
      animate_fem(V,u,t,color,linestyle)
    case 'surface':
      surface_fem(V,u,t)
    case 'fade':
      fade_fem(V,u,t,color,linestyle)
    case _:
      raise RuntimeError('Error: il type in input è sbagliato')

def animate_fem(V,u,t,c,s):
    def drawframe(i):
      uh = dof2fun(u[:,i],V)
      fig = plt.figure(figsize = (6, 5))
      ax = fig.subplots()
      plt.xlabel('x')
      plt.ylabel('u(x,t)')
      plt.title('Current time: t = %.2f' %t[i] )
      plt.xlim(min(dofs(V)),max(dofs(V)))
      plt.ylim((np.min(np.min(u)), np.max(np.max(u))))
      plt.yticks(np.linspace(np.min(np.min(u)), np.max(np.max(u)), num=11))
      plot(uh,color=c,linestyle=s)

    rnd = np.random.randint(50000)

    savegif(drawframe, frames = len(t), name = "temp%d-gif.gif" % rnd, dt = 150)
    from IPython.display import Image, display
    display(Image("temp%d-gif.gif" % rnd), metadata={'image/gif': {'loop': True}})
    from os import remove
    remove("temp%d-gif.gif" % rnd)

# salvare formato gif
def savegif(drawframe, frames, name, dt = 1.0/24.0):
  arrays = []
  for i in range(frames):
    drawframe(i)
    # fissare glia assi
    fig = plt.gcf()
    fig.canvas.draw()
    arrays.append(np.array(fig.canvas.renderer.buffer_rgba()))
    plt.close(fig)

  imageio.mimsave(name.replace(".gif", "") + ".gif", arrays, duration = dt)

def surface_fem(V,u,t):
  """ Soluzione vista dall'alto
  Input:
  x         (numpy.ndarray)-> vector  Baricentri delle celle
  t         (numpy.ndarray)-> vector  Tempi d'evoluzione
  u         (numpy.ndarray)-> matrix  Approssimazione della soluzione. Vige la convenzione uij = u(xi,tj).
  """
  X,T = np.meshgrid(dofs(V), t, indexing='ij')

  #vista dall'alto
  fig1, ax1= plt.subplots()
  plt.figure(1, figsize=(8,8))
  plt.pcolor(X, T, u,linewidth=2,cmap='plasma')
  ax1.set_xlabel('x')
  ax1.set_ylabel('t')
  plt.title("Vista dall'alto")
  plt.colorbar()

  # # surface
  # fig2 = plt.figure(2, figsize=(8,8))
  # ax2 = fig2.add_subplot(projection = '3d')
  # surf = ax1.plot_surface(X, T, u, linewidth=0, antialiased=False, shade = True, alpha = 0.8, cmap='plasma')
  # ax2.set_xlabel('x')
  # ax2.set_ylabel('t')
  # ax2.set_zlabel('u(x,t)')
  # plt.title("Surface")

  # ax2.view_init(30, -90)

  plt.show()

from math import ceil
def fade_fem(V,u,t,c,s):
  nt = t.size
  if(nt>10):
      dt = ceil(nt/10)
      np = 10
  else:
      dt = 1
      np = nt

  # fig, ax= plt.subplots()
  j = 1;
  while(j<nt):
      uh = dof2fun(u[:,j],V)
      C=(255, 0, 128)
      plot(uh, color=c, alpha=(nt-j)/nt, linestyle=s)
      j = j+dt;